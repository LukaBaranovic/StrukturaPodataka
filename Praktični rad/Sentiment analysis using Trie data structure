#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#define BUFFER 256


typedef struct Node* position;
struct Node {
	char caracter;
	int sentiment;
	int type;
	position next_brother;
	position next_child;
};



void read_from_file(position);
void append_word(position, char*, int);
void display_directory_main(position, int);
position append_caracter(position, char);
position create_child(position, char);
position append_brother(position, char);


int main() {
	position trie = (position)malloc(sizeof(struct Node));
	trie->next_brother = NULL;
	trie->next_child = NULL;

	read_from_file(trie);
	display_directory_main(trie->next_child, 0);

}


void read_from_file(position head) {
	FILE* fp = fopen("rijeci.txt", "r");
	char* source = NULL;
	source = (char*)malloc(BUFFER * sizeof(char));
	char* word = NULL;
	word = (char*)malloc(BUFFER * sizeof(char));

	if (fp == NULL)
		printf("Eror reading file");


	int offset = 0;
	int  sentiment = 0;


	while (!feof(fp)) {
		fgets(source, BUFFER, fp);


		sscanf(source, " %s %d %n", word, &sentiment, &offset);
		while (offset != 0) {

			append_word(head, word, sentiment);

			printf(" %s - %d \n", word, sentiment);
			source += offset;
			offset = 0;
			sscanf(source, " %s %d %n", word, &sentiment, &offset);
		}

	}
	printf("\n");
}

void append_word(position head, char* word, int sentiment) {
	char caracter;
	int type = 0;
	int offset = 0;

	sscanf(word, " %c%n", &caracter, &offset);
	
	while (offset != 0) {
		head = append_caracter(head, caracter);
		word += offset;
		offset = 0;
		sscanf(word, " %c%n", &caracter, &offset);

	}
	sscanf(word, " %d%n", &type, &offset);
	word += offset;

	head->sentiment = sentiment;
	head->type = 1;
}


position append_caracter(position head, char caracter) {
	if (head->next_child == NULL)
		head = create_child(head, caracter);
	else if (head->next_child != NULL)
		head = append_brother(head, caracter);

	return head;
}

position append_brother(position head, char caracter) {
	position tmp = (position)malloc(sizeof(struct Node));
	tmp->next_brother = NULL;
	tmp->next_child = NULL;
	tmp->caracter = caracter;
	
	if (head->next_child->caracter > caracter) {
		tmp->next_brother = head->next_child;
		head->next_child = tmp;
		head = head->next_child;
		return head;
	}
	else {
		head = head->next_child;
		while (head->next_brother != NULL && (head->next_brother->caracter < caracter)) {
			head = head->next_brother;
		}
		if (head->caracter == caracter)
			return head;
		else {
			tmp->next_brother = head->next_brother;
			head->next_brother = tmp;
			head = head->next_brother;
			return head;
		}
	}
	
}


position create_child(position head, char caracter) {
	position tmp = (position)malloc(sizeof(struct Node));
	tmp->next_brother = NULL;
	tmp->next_child = NULL;

	tmp->caracter = caracter;
	head->next_child = tmp;
	
	return head->next_child;
}


void display_directory_main(position head, int offset) {
	position tmp = head;
	int i;

	while (tmp != NULL) {
		for (i = 0; i < offset; i++) {
			printf("  ");
		}
		
		printf("-%c \n", tmp->caracter);

		if (tmp->next_child != NULL)
			display_directory_main(tmp->next_child, offset + 1);

		if (tmp->type == 1) {
			printf("Kraj rijeci!, sentiment: %d \n", tmp->sentiment);
		}

		tmp = tmp->next_brother;
	}
}

